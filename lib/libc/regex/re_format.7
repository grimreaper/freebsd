.\" Copyright (c) 2011 Gabor Kovesdan <gabor@FreeBSD.org>.
.\" Copyright (c) 1992, 1993, 1994 Henry Spencer.
.\" Copyright (c) 1992, 1993, 1994
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" This code is derived from software contributed to Berkeley by
.\" Henry Spencer.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"	@(#)re_format.7	8.3 (Berkeley) 3/20/94
.\" $FreeBSD$
.\"
.Dd October 6, 2011
.Dt RE_FORMAT 7
.Os
.Sh NAME
.Nm re_format
.Nd POSIX 1003.2 regular expressions
.Sh DESCRIPTION
Regular expressions
.Pq Dq RE Ns s ,
as defined in
.St -p1003.2 ,
come in two forms:
modern regular expressions (roughly those of
.Xr egrep 1 ;
1003.2 calls these
.Dq extended
regular expressions or
.Dq EREs )
and obsolete regular expressionss (roughly those of
.Xr ed 1 ;
1003.2 calls these
.Dq basic
regular expressions or
.Dq BREs ) .
BREs mostly exist for backward compatibility in some old programs;
they will be discussed at the end.
.St -p1003.2
leaves some aspects of regular expression syntax and semantics open,
so this manual will describe the behavior of this implementation
instead of just reproducing the same iformation that is already
available in the standard.
.Pp
An extended regular expression is one or more non-empty
.Em branches ,
separated by
.Ql \&| .
It matches anything that matches one of the branches.
.Pp
A branch is one or more
.Em pieces ,
concatenated.
It matches a match for the first, followed by a match for the second, etc.
.Pp
A piece is an
.Em atom
possibly followed
by a single
.Ql \&* ,
.Ql \&+ ,
.Ql \&? ,
or
.Em bound .
An atom followed by
.Ql \&*
matches a sequence of 0 or more matches of the atom.
An atom followed by
.Ql \&+
matches a sequence of 1 or more matches of the atom.
An atom followed by
.Ql ?\&
matches a sequence of 0 or 1 matches of the atom.
.Pp
A
.Em bound
is an expression that allows the repetition of the atom
according to the specified constraints.
A
.Em bound
starts with an opening brace
.Pq Ql \&{
character, followed by an unsigned decimal integer, an optional comma
.Pq Ql \&,
followed by another unsigned decimal integer,
always followed by a closing brace
.Pq Ql \&} .
The integers must lie between 0 and
.Dv RE_DUP_MAX
inclusive.
The integers restrict the minimum and maximum repetition count of the atom
and the first number may not exceed the second.
The second integer is optional and if it is missing but the comma is present,
there is no upper limit of the repetition.
If there is only one integer specified and the comma is also missing,
exactly the specified number of repetitions is required.
In this implementation,
it is also possible to leave out the first integer and only specify the
comma and the upper limit.
In this case 0 is implied as a minimum repetition count.
.Pp
An atom is a regular expression enclosed in
.Ql ()
(matching a match for the
regular expression),
an empty set of
.Ql ()
(matching the null string),
a
.Em bracket expression
(see below),
.Ql .\&
(matching any single character),
.Ql \&^
(matching the null string at the beginning of a line),
.Ql \&$
(matching the null string at the end of a line), a
.Ql \e
followed by one of the characters
.Ql ^.[$()|*+?{\e
(matching the escaped character taken as an ordinary character)
or a single character with no other significance (matching the
same character).
A
.Ql \&{
followed by a character other than a digit is an ordinary
character, not the beginning of a bound.
It is illegal to end a regular expression with
.Ql \e .
.Pp
A
.Em bracket expression
is a list of characters enclosed in
.Ql [] .
It always matches a single character but the set of matching characters
is determined by more specific rules.
If the list begins with
.Ql \&^ ,
it matches any single character that is not present in the rest of the
list.
If the list does not begin with
.Ql \&^ ,
normally all characters that are listed in the brackets will match.
An exception from this is the use of collating ranges.
If there is a
.Ql \&- ,
which is not the first character in the bracket,
it will be interpreted as a collating range and will match all
characters that fall in between the preceding and following characters
(inclusive) in the current locale's collating order.
.No For example, Ql [a0-9]
in ASCII matches
.Ql a
or any decimal digit.
.No For example, Ql [^agh]
matches any character that is not
.Ql a ,
.Ql g ,
or
.Ql h .
.Pp
To include a literal
.Ql \&]
in the list, make it the first character
(following a possible
.Ql \&^ ) .
To include a literal
.Ql \&- ,
make it the first or last character,
or the second endpoint of a range.
To use a literal
.Ql \&-
as the first endpoint of a range,
enclose it in
.Ql [.\&
and
.Ql .]\&
to make it a collating element (see below).
With the exception of these and some combinations using
.Ql \&[
(see next paragraphs), all other special characters, including
.Ql \e ,
lose their special significance within a bracket expression.
.Pp
Within a bracket expression, a collating element (a character,
a multi-character sequence that collates as if it were a single character,
or a collating-sequence name for either)
enclosed in
.Ql [.\&
and
.Ql .]\&
stands for the
sequence of characters of that collating element.
The sequence is a single element of the bracket expression's list.
A bracket expression containing a multi-character collating element
can thus match more than one character,
e.g.\& if the collating sequence includes a
.Ql ch
collating element,
then the regular expression
.Ql [[.ch.]]*c
matches the first five characters
of
.Ql chchcc .
.Pp
Within a bracket expression, a collating element enclosed in
.Ql [=
and
.Ql =]
is an equivalence class, standing for the sequences of characters
of all collating elements equivalent to that one, including itself.
(If there are no other equivalent collating elements,
the treatment is as if the enclosing delimiters were
.Ql [.\&
and
.Ql .] . )
For example, if
.Ql x
and
.Ql y
are the members of an equivalence class,
then
.Ql [[=x=]] ,
.Ql [[=y=]] ,
and
.Ql [xy]
are all synonymous.
An equivalence class may not be an endpoint
of a range.
.Pp
Within a bracket expression, the name of a
.Em character class
enclosed in
.Ql [:
and
.Ql :]
stands for the list of all characters belonging to that
class.
Standard character class names are:
.Bl -column "alnum" "digit" "xdigit" -offset indent
.It Em "alnum	digit	punct"
.It Em "alpha	graph	space"
.It Em "blank	lower	upper"
.It Em "cntrl	print	xdigit"
.El
.Pp
These stand for the character classes defined in
.Xr ctype 3 .
A particular locale may provide others.
A character class may not be used as an endpoint of a range.
.Pp
A bracketed expression like
.Ql [[:class:]]
can be used to match a single character that belongs to a character
class.
The reverse, matching any character that does not belong to a specific
class, the negation operator of bracket expressions may be used:
.Ql [^[:class:]] .
.Pp
In the event that a regular expression  could match more than one
substring of a given string,
the regular expression matches the one starting earliest in the string.
If the regular expression could match more than one substring starting
at that point,
it matches the longest.
Subexpressions also match the longest possible substrings, subject to
the constraint that the whole match be as long as possible,
with subexpressions starting earlier in the regular expression taking
priority over ones starting later.
Note that higher-level subexpressions thus take priority over
their lower-level component subexpressions.
.Pp
Match lengths are measured in characters, not collating elements.
A null string is considered longer than no match at all.
For example,
.Ql bb*
matches the three middle characters of
.Ql abbbc ,
.Ql (wee|week)(knights|nights)
matches all ten characters of
.Ql weeknights ,
when
.Ql (.*).*\&
is matched against
.Ql abc
the parenthesized subexpression
matches all three characters, and
when
.Ql (a*)*
is matched against
.Ql bc
both the whole regular expression and the parenthesized
subexpression match the null string.
.Pp
The effect of case-independent match is like as if all case distinctions
vanished from the alphabet.
It can also be modelled as if each and every character were replaced
by a bracket expression,
containing both cases of the same letter,
.No e.g. Ql x
becomes
.Ql [xX] .
When it appears inside a bracket expression, all case counterparts
of it are added to the bracket expression, so that (e.g.)
.Ql [x]
becomes
.Ql [xX]
and
.Ql [^x]
becomes
.Ql [^xX] .
.Pp
No particular limit is imposed on the length of regular expression.
Programs intended to be portable should not employ regular expressions
longer than 256 bytes,
as an implementation can refuse to accept such regular expressions and
remain POSIX-compliant.
.Pp
Basic regular expressions differ in several respects.
.Ql \&|
is an ordinary character and there is no equivalent
for its functionality.
.Ql \&+
and
.Ql ?\&
are ordinary characters, and their functionality
can be expressed using bounds
.No ( Ql {1,}
or
.Ql {0,1}
respectively).
Also note that
.Ql x+
in extended regular expressions is equivalent to
.Ql xx* .
The delimiters for bounds are
.Ql \e{
and
.Ql \e} ,
with
.Ql \&{
and
.Ql \&}
by themselves ordinary characters.
The parentheses for nested subexpressions are
.Ql \e(
and
.Ql \e) ,
with
.Ql \&(
and
.Ql \&)
by themselves ordinary characters.
.Ql \&^
is an ordinary character except at the beginning of the regular expression
or the beginning of a parenthesized subexpression,
.Ql \&$
is an ordinary character except at the end of the
regular expression or the end of a parenthesized subexpression,
and
.Ql \&*
is an ordinary character if it appears at the beginning of the
regular expresssion or the beginning of a parenthesized subexpression
(after a possible leading
.Ql \&^ ) .
Finally, there is one new type of atom, a
.Em back reference :
.Ql \e
followed by a non-zero decimal digit
.Em d
matches the same sequence of characters
matched by the
.Em d Ns th
parenthesized subexpression
(numbering subexpressions by the positions of their opening parentheses,
left to right),
so that (e.g.)
.Ql \e([bc]\e)\e1
matches
.Ql bb
or
.Ql cc
but not
.Ql bc .
.Pp
Back references are not defined for extended regular expressions but
most implementations (including this) implement them.
.Sh SEE ALSO
.Xr regex 3
.Rs
.%T Regular Expression Notation
.%R IEEE Std
.%N 1003.2
.%P section 2.8
.Re
.Sh HISTORY
This manual was originally written by
.An Henry Spencer
for an older implementation and later extended and
tailored for TRE by
.An Gabor Kovesdan .
The regex implementation comes from the TRE project
and it was included first in
.Fx 10-CURRENT.
